---
title: Java的垃圾收集
date: 2020-03-18T13:17
author: codezhw
top: false
summary: 这是阅读《深入理解Java虚拟机:JVM高级特性与最佳实践(第3版)》的读书笔记，记录学习过程以及一些自己的理解。
categories: JVM
tags: 
	- Java
	- 读书笔记

---







# Java的垃圾收集



## 前言



早在Java诞生之前，就有了第一门内存动态分配和垃圾收集的语言Lisp。

垃圾收集（Garbage Collection）无非从三个角度去考虑。

- **哪些内存需要回收？**
- **什么时候回收？**
- **如何回收？**





先如今的内存动态分配与垃圾收集的计数已经相当成熟，为什么我们还要去了解垃圾回收的机制呢？

答案是：`当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。`



- **哪些内存需要回收？**

我们都知道在Java内存运行时`程序计数器、虚拟机栈、本地方法栈`是线程私有的，随线程而生，随线程结束而灭。

虚拟机栈中主要存放的局部变量表基本上对象创建过程中的`类加载机制检测`中确定下来。所以这部分的内存确定与收回都是具备确定性的。当方法结束或者线程结束，内存自然而然的回收了。

而`Java堆和方法区`这两个区域则有着很显著的不确定性：一个对象的实例数据只有处于运行时期，我们才能够知道占用了多少内存，所以这部分的内存分配与回收是动态的。



- **什么时候回收？**

理想的认为对象`消亡`就回收，对象`存活`就不回收呗。



**那怎么去确定对象的存活与消亡呢？**









## 判断对象存活的两大算法：

判断对象存活的两大算法：

​	1.引用计数算法

​	2.可达性分析算法



### 引用计数算法

引用分析算法的主要思想：`在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。`



引用分析算法优缺点很明显：

​	优点：它的算法简单，因此效率很高，在很多领域都有应用。

​	缺点：算法过于简单，无法处理复杂的情况，假设有两个对象他们互相持有对方的引用，除此之外再无其他引用，这样会导致他们的引用计数器永远不为0，所以他们无法被回收。



我们用Java实现这个例子来看一下Java会不会回收这两个对象。

```java
public class Demo1 {

    private static final int _1mb = 1024*1024;
    public Object instance = null;
    private byte[] bigSize = new byte[2 * _1mb];

    public static void testGc () {
        Demo1 demo1 = new Demo1 ( );
        Demo1 demo2 = new Demo1 ( );

        demo1.instance = demo2;
        demo2.instance = demo1;
        
        demo1 = null;
        demo2 = null;
        System.gc ( );
    }

    public static void main ( String[] args ) {
        Demo1.testGc ( );
    }
}
```

![image-20200318141816294](C:\Users\USERzhw\AppData\Roaming\Typora\typora-user-images\image-20200318141816294.png)

可以看到对象依然被回收了，这也侧面证明了我们`Java虚拟机并不是通过引用计数器去判断对象是否消亡`。





### 可达性分析算法

当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为`“GC Roots”的根对象作为起始节点集`，**从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GCRoots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。**



![](https://gitee.com//CODEZHW/blogimage/raw/master/img/20200318143148.png)

在这里例子中：**对象OBJ5、OBJ6、OBJ7仍然具有引用关系，但是它们到GC ROOT是不可达的，所以它们是可回收对象，同理OBJ1.OBJ2.OBJ3是可达的，所以它们是不可回收对象**



**固定的几种GCROOT：**

- 虚拟机栈中（局部变量表中）的引用对象
- 方法区中类静态属性应用对象
- 方法区中常量引用对象
- 本地方法中Native方法引用的对象
- 同步锁的持有对象



除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，目前最新的几款垃圾收集器无一例外都具备了局部回收的特征，为了避免GC Roots包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。



## 四大引用



上述的两种算法，判断对象的存活与否都离不开----`引用`.

在JDK1.2以前引用的定义都是很传统的：如果reference类型的数据中存储的是另一个内存区域的起始地址，那么就称这个reference数据表示某个对象或内存的引用。

这样的定义没有什么问题，但是我们并不希望引用只有两种状态`被引用`和`未被引用`。

在JDK1.2改版之后,Java将引用的概念进行了扩充将其按照强弱顺序分为了四大引用。



- **强引用 : 是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。**
- **软引用 ：一些还有用，但非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。**
- **弱引用 ：被弱引用关联的对象只能生存到下一次垃圾收集发生为止。**
- **虚引用 : 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。**





## 垃圾收集算法

**垃圾收集算法**

从判定对象是否消亡的角度出发，垃圾收集算法也分为两类：

1. **引用计数式垃圾收集**
2. **追踪式垃圾收集**

由于引用计数式垃圾收集算法在主流虚拟机中很少使用，所以讨论追踪式垃圾收集。



**分代收集理论**

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计。

这个理论建立在两个分代假说之上：

1. **弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的**
2. **强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。**



这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：**收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。**显而易见，`如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象`，就能以较低代价回收到大量的空间；如`果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用`。

因而才有了`Minor GC`、`Major GC`、`Full GC`这样的回收类型的划分。也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了`标记-复制算法`、`标记-清除算法`和`标记-整理算法`等针对性的垃圾收集算法。



一般情况下会Java堆中划分为`新生代（Young Generation）`和`老年代（Old Generation）`



针对不同分代的类似名词：

- 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
   - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
   - 年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
   - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。





### 标记-清除算法

最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，在1960年由Lisp之父John McCarthy所提出。

如它的名字一样，算法分为`标记`和`清除`两个阶段：**首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。**



之所以说它是最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。

主要的两个缺点：

- **第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。**
- **内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。**



![标记-清除算法](https://gitee.com//CODEZHW/blogimage/raw/master/img/20200318205839.png)





### 标记-复制算法

标记-复制算法常被简称为复制算法。

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，**标记-复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。**

如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。

这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。

![标记-复制算法](https://gitee.com//CODEZHW/blogimage/raw/master/img/20200318210421.png)





### 标记-整理算法

标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

标记-整理”（Mark-Compact）算法，**其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。**



标记-清除算法与标记-整理算法的本质差异在于前者是`一种非移动式的回收算法，而后者是移动式的`。是否移动回收后的存活对象是一项优缺点并存的风险决策：



![标记-整理算法](https://gitee.com//CODEZHW/blogimage/raw/master/img/20200318210816.png)