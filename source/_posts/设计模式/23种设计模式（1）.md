---
  title: 23种设计模式
  date: 2020-02-25 13:46
  author: codezhw
  top: false
  summary: 这是一篇介绍设计模式的文章，其中主要介绍了创建型模式下的工厂模式，抽象工厂，建造者模式，原型模式，单例模式。
  categories: 设计模式
  tags: 
      - Java

---





# 23种设计模式



## 软件设计模式的概念：

> 软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。



**在软件设计模式之中，最出名的莫过于GoF(Gang of Four)**

**GoF在《设计模式：可复用面向对象软件的基础》一书种收录了23种设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。**

### 设计模式的六大原则：

>  **总原则：扩展开放，对修改关闭**
>
> 在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。
>
> 1、单一职责原则
>
> 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。
>
> 2、里氏替换原则
>
>  里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。
>
>  3、依赖倒转原则
>
> 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
>
> 4、接口隔离原则
>
>  这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。
>
>  5、迪米特法则（最少知道原则）
>
> 就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。
>
>  6、合成复用原则
>
> 原则是尽量首先使用合成/聚合的方式，而不是使用继承。

### 从概念上简单介绍这23种设计模式



>* **单例模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。**
>
>* **原型模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。**
>
>* **工厂方法模式：定义一个用于创建产品的接口，由子类决定生产什么产品。**
>
>* **抽象工厂模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。**
>
>* **建造者模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。**
>
>* **代理模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。**
>
>* **适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。**
>
>* **桥接模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。**
>
>* **装饰模式：动态的给对象增加一些职责，即增加其额外的功能。**
>
>* **外观模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。**
>
>* **享元模式：运用共享技术来有效地支持大量细粒度对象的复用。**
>
>* **组合模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。**
>
>* **模板方法模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。**
>
>* **策略模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。**
>
>* **命令模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。**
>
>* **职责链模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。**
>
>* **状态模式：允许一个对象在其内部状态发生改变时改变其行为能力。**
>
>* **观察者模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。**
>
>* **中介者模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。**
>
>* **迭代器模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。**
>
>* **访问者模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。**
>
>* **备忘录模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。**
>
>* **解释器模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。**

### 根据其用途划分我们将其分为三大类

* 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
* 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
* 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

## 创建型模式

**创建型模式的特点**

> **创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。**
>
> **创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。**

---

## 工厂方法模式

工厂方法模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。

核心本质

- **实例化对象不适用new，用工厂方法代替**
- **将选择实现类，创建对象统一管理和控制，从而将调用者跟我们的实现类解耦。**

工厂方法模式的主要优点有：

- **用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；**
- **在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；**


其缺点是：**每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。**



下面举例：

- **传统方法**

```java
//car接口
interface Car{
   void name();
}

//宝马实体类继承Car
class BMW implements Car{
    @Override
    public void name () {
        System.out.println ( "宝马" );
    }
}

//奔驰实体类继承Car
class MB implements Car{
    @Override
    public void name () {
        System.out.println ( "奔驰" );
    }
}

public class FactorMode {
    public static void main ( String[] args ) {
        Car bmw = new BMW ( );
        Car mb = new MB ( );
        bmw.name ();
        mb.name ();
    }
}
```

这是我们平常创建对象的方法，创建一个Car接口， 创建各种各样品牌的车（类）去继承这个Car接口，然后调用  Car xx = new xx(); 这样去得到一个xx品牌的车。

- 工厂方法**

```java
//生成car的工厂
class CarFactory {
    public static Car getCar ( String car ) {
        if (car.equals ( "奔驰" )) {
            return new MB ( );
        } else if (car.equals ( "宝马" )) {
            return new BMW ( );
        }
        return null;
    }
}
```

```java
public class FactorMode {
    public static void main ( String[] args ) {
        Car bmw = CarFactory.getCar ( "宝马" );
        Car mb = CarFactory.getCar ( "奔驰" );
        bmw.name ();
        mb.name ();
    }
}
```

![关系依赖图](https://i.loli.net/2020/02/25/OghYlX4GKxsn329.png)

可以看到，我们想要得到不同品牌的汽车实现类的时候，不用去new一个对象，直接传递参数给CarFactory就可以得到我们想要的汽车。

简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。

> **我们强调职责单一原则，一个类只提供一种功能，CarFactory 的功能就是只要负责生产各种 Car。**



那假如呢，我们想要得到摩拜单车，那该怎么做呢？

只能去创建一个摩拜单车实体类，然后修改CarFactory里面的方法，添加创建摩拜单车的方法。

这样做的缺陷在于：我们想要去添加新的品牌汽车的时候，要去修改CarFactory，不满足我们的 **对修改关闭，对扩展开放原则**。

**解决方案：**

> **从上面的案例中我们可以看出，区别与传统的创建对象方法，我们在原有的基础上，建立了一个 CarFactory 去根据传入的参数创建了我们想要得到的对象，这样符合（将产品对象的实际创建工作推迟到具体子工厂类当中）这一要求。**
>
> **那么我们可以创建某个品牌车的车工厂， 然后车工厂继承CarFactory,  CarFactory中只有一个得到车的方法。**
>
> **这样当我们想要添加新的品牌车的时候，只需要创建对应的车工厂类，然后继承CarFactory 这样符合了我们（对修改关闭，对扩展开放） 的原则，这就是简单工厂方法模式**

---



##  简单工厂方法模式



- **简单工厂方法**

```java
//所有的车共有组件
interface Car {
    void name ();
}

//所有车的工厂
interface CarFactory {
    Car getCar ();
}

//奔驰车工厂
class BMWFacrot implements CarFactory {

    @Override
    public Car getCar () {
        return new BMW ( );
    }
}

//宝马车工厂
class MBFacrot implements CarFactory {

    @Override
    public Car getCar () {
        return new MB ( );
    }
}

//宝马车实体类
class BMW implements Car {

    @Override
    public void name () {
        System.out.println ( "宝马" );
    }
}

//奔驰车实体类
class MB implements Car {
    @Override
    public void name () {
        System.out.println ( "奔驰" );
    }
}

public class FactoryMethodPattern {
    public static void main ( String[] args ) {
        Car bwm = new BMWFacrot ( ).getCar ();
        Car mb = new  MBFacrot( ).getCar ();
        mb.name ();
        bwm.name ();
    }
}


```

- **新增**

```java
class MobaiBicycle implements Car{

    @Override
    public void name () {
        System.out.println ( "摩拜单车拉拉！！" );
    }
}

class MoBaiBicycleFactory implements CarFactory{

    @Override
    public Car getCar () {
        return new MobaiBicycle ();
    }
}

public class FactoryMethodPattern {
    public static void main ( String[] args ) {
        Car bwm = new BMWFacrot ( ).getCar ();
        Car mb = new  MBFacrot( ).getCar ();
        mb.name ();
        bwm.name ();

        //新添加的摩拜单车
        Car mobai = new  MoBaiBicycleFactory ( ).getCar ();
        mobai.name ();
    }
}
```

- **运行结果**

  ​	**奔驰**
  ​	**宝马**
  ​	**摩拜单车拉拉！！**



![依赖图](https://i.loli.net/2020/02/25/C38NjHY51iZms2K.png)

---

## 抽象工厂方法模式



**定义：**

抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，无需为他们指定具体的实现类

**优点：**

具体产品在应用层的代码隔离，无需关心创建的细节

将一个系列的产品统一到一起创建

**缺点：**

规定了所有可能被创建的产品集合，产品族中拓展新的产品困难

增加了系统的抽象性和理解难度

![关系类图](https://i.loli.net/2020/02/25/xoZlOYQMvIb4ePB.png)



由于代码有点多就不全部展示，只对其中的类做讲解。

IProductFactory ：所有工厂的总工厂，其中包含要生产的产品。

Iphone、Router： 手机产品、路由器产品。

XiaomiFactory：小米工厂，生产小米的产品。

HuaweiFactory： 华为工厂，生产华为的产品。

```java
public class Client {
    public static void main ( String[] args ) {
        System.out.println ( "--------小米--------" );
        XiaomiFactory xiaomiFactory = new XiaomiFactory ( );
        Iphone iphone = xiaomiFactory.iphone ( );
        iphone.sendmsg ();
        iphone.start ();
        iphone.shutdown ();
        Router router = xiaomiFactory.router ( );
        router.start ();
        router.openwifi ();
        router.shutdown ();

        System.out.println ( "--------华为--------" );
        HuaweiFactory huawei = new HuaweiFactory ( );
        Iphone iphone1 = huawei.iphone ( );
        iphone1.sendmsg ();
        iphone1.start ();
        iphone1.shutdown ();
        Router router1 = huawei.router ( );
        router1.start ();
        router1.openwifi ();
        router1.shutdown ();
    }
}
```

- **运行结果**

![](https://i.loli.net/2020/02/25/rn6POINJW457FoU.png)

> 当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了**对修改关闭，对扩展开放**这个设计原则。

关于产品等级结构和产品族

![](https://i.loli.net/2020/02/25/kj6qLSlFnVpEbsZ.png)



---



### 工厂方法模式在JDK中的应用

- **简单工厂方法**

**java.util.Calendar包下的createCalendar方法**

**这里贴出的源码只截取了与简单工厂方法相关的。**

```java
//标准的静态方法
private static Calendar createCalendar(TimeZone zone,  Locale aLocale)
{
  /*
  *还有其他内容
  **/
    
    //根据传入的值，创建不同的对象
    if (aLocale.hasExtensions()) {
        String caltype = aLocale.getUnicodeLocaleType("ca");
        if (caltype != null) {
            switch (caltype) {
            case "buddhist":
            cal = new BuddhistCalendar(zone, aLocale);
                break;
            case "japanese":
                cal = new JapaneseImperialCalendar(zone, aLocale);
                break;
            case "gregory":
                cal = new GregorianCalendar(zone, aLocale);
                break;
            }
        }
    }
   
    return cal;
}
```

- **抽象工厂方法**

先看一张关系图

![Collection中的依赖](https://i.loli.net/2020/02/25/RYNOkEDtBngZHVj.png)

Collection接口中的Iterator<E> iterator();方法，这个方法继承自Iterable()不重要

可以把Collection看作总的抽象工厂，其中的Iterable()方法等等其他方法都可以看作是Collection的产品。

Collection工厂把这些产品交给 各自的工厂(ArrayList、HashSet),去实现各自的功能。



```java
//这是ArrayList中的iterator方法
public Iterator<E> iterator() {
    return new Itr();
}
```

而Itr()就是ArrayList自己实现的内部类，里面定义属于ArrayList的hasNext()、next() 。。。等等这些方法。

![Itr内部类](https://i.loli.net/2020/02/25/c4yLfsXxE6lhka5.png)

用这些方法去遍历ArrayList。

**总的产品Iterator接口里面会定义产品所需功能的细节，然后在交给各个品牌不同的工厂来实现**



> 　　**看懂上面的之后就特别好理解抽象工厂，抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；（比如Iterator()方法的不同实现）而抽象工厂模式则需要面对多个产品等级结构（Collection接口下的不同方法,）。再说明白一点就是：Collection就是一个抽象工厂，它提供了一个产品类的库，所有产品都以同样接口出现，从而使客户端不依赖于具体实现。工厂方法则是抽象工厂里面的其中一个产品类，并且把这个方法的实例化放入具体的实现类中** 



---

##  单例模式



**保证一个类只有一个实例，并且提供一个访问该实例的全局访问点**



**优点**

* 由于单例模式只能生成一个实例，减少了系统的性能开销。
* 单例模式可以再系统设置全局的访问点，优化共享资源的访问。



**常见的五种单例模式的实现方式**

* 饿汉式 
* 懒汉式
* DCL懒汉式
* 饿汉式改进
* 枚举单例



- **饿汉式**

```java
public class Singletondemo1 {

    //构造器私有化
    private Singletondemo1(){
    }

    //类初始化时，立即加载这个对象 不会涉及多线程问题
    private static Singletondemo1 instance = new Singletondemo1 ();

    //提供获取该对象的方法
    public static Singletondemo1 getInstance(){
        return instance;
    }
}

class demotest{
    public static void main ( String[] args ) {
        Singletondemo1 instance = Singletondemo1.getInstance ();
        Singletondemo1 instance2 = Singletondemo1.getInstance ();

        if (instance == instance2) {
            System.out.println ( "true" );
        }
    }
}
```

**饿汉模式的问题**

> 假设我们在单例模式中开辟了许多的空间， private byte []data1 = new byte[1024];... 很多很多
>
> 那么这些空间会随着Static方法创建并占用内存，如果我们长时间不去调用instance实例，这些空间就浪费了。
>
> 解决方案就是再添加一个方法去创建instance实例，这就是**懒汉式**



- **懒汉式**

```java
public class Singletondemo2 {
    //构造器私有化
    private Singletondemo2(){
    }

    //类初始化时，不加载这个对象 会涉及多线程问题
    private static Singletondemo2 instance;

    //提供了获取该对象的方法，有synchronized，效率会降低
    public static synchronized Singletondemo2 getInstance(){
        if (instance ==null){
            instance = new Singletondemo2 ();
        }
        return instance;
    }

}
```

- **DCL懒汉式**

```java
private Singletondemo3(){
}
//类初始化时，立即加载这个对象 不会涉及多线程问题
private volatile static Singletondemo3 instance;


public static  Singletondemo3 getInstance(){
    if (instance ==null){
        //线程竞争这个锁，获得锁的线程进来，去判断是否创建实例。
        synchronized(Singletondemo3.class){
            if (instance ==null){}
            instance = new Singletondemo3 ();// 不是一个原子性的操作
           /*
            1、分配内存空间  
            2、执行构造方法，初始化对象 
            3、把这个对象指向这个空间 
            * 123 线程走A没问题
            * 132 假设一个线程B走132后，再进来一个线程，就不会判断instance ==null 直接返回了
            *此时的instance 还没完成初始化
            **/
            
        }
    }
    return instance;
}
```

**双重检测锁，将锁的范围更加精细化。**

**只有在线程进来后，判断是否创建对象，如果没有就创建，有就返回。**



```java
public class Singletondemo4 {
    private Singletondemo4(){
    }
    private static class InnerClass{
        private static final Singletondemo4 instance = new Singletondemo4 ();
    }

    public  static Singletondemo4 getInstance(){
        return InnerClass.instance;
    }

}

class demotest2{
    public static void main ( String[] args ) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Singletondemo4 instance = Singletondemo4.getInstance ();
        Singletondemo4 instance2 = Singletondemo4.getInstance ();
        Constructor <Singletondemo4> declaredConstructor = Singletondemo4.class.getDeclaredConstructor ( null );
        declaredConstructor.setAccessible ( true );
        Singletondemo4 instance3 = declaredConstructor.newInstance ( );
        System.out.println ( instance == instance3 );

    }
}
```

**我们都知道通过反射可以创建，而且反射中的方法可以强制忽略private关键字，这样我们的单例模式还是不安全**

**通过序列化与反序列化操作也可以破坏双重校验锁的模式**

**我们点进newInstance ( )方法可以看到：**

![](https://i.loli.net/2020/02/25/NfT5OCywLaJvim3.png)

**如果反射想要创建的对象是枚举类型，就会抛出一样异常，所以我们可以通过枚举来创建单例模式来防止通过反射破坏单例，枚举创建的单例模式线程安全，创建简单，但是无法延时加载**

- **枚举**

```
public enum Singletondemo5 {
    INSTANCE;
    public Singletondemo5 getInstance(){
        return INSTANCE;
    }
}

class demo5{
    public static void main ( String[] args ) {
        Singletondemo5 instance = Singletondemo5.INSTANCE;
        Singletondemo5 instance1 = Singletondemo5.INSTANCE;

        System.out.println ( instance == instance1 );
    }
}
```

![枚举的知识](https://i.loli.net/2020/02/25/AerbMunQ3xBRmhs.png)

### 单例模式在JDK中的应用

```java
public class Runtime {
    private static final Runtime currentRuntime = new Runtime();

    private static Version version;


    public static Runtime getRuntime() {
        return currentRuntime;
        
        
     /*
     *一下省略部分代码
     **/
    }
```

我们熟知在Spring中Bean的创建也有单例模式，我们等到解读Spring 源码的时候在做分析。

---

## 建造者模式



概念：

　　将一个复杂对象的构建与它的表示分离。使得同样构建过程可以创建不同表示

适用场景：

1. 一个对象有很多属性的情况下
2. 想把复杂的对象创建和使用分离

优点：

　　封装性好，扩展性好





```java
//建造者
public abstract class Builder {

    abstract   Builder builderA(String msg);//汉堡
    abstract   Builder builderB(String msg);//可乐
    abstract   Builder builderC(String msg);//薯条
    abstract   Builder builderD(String msg);//甜点

    abstract Product getproduct();
}
```

```java
//产品类
public class Product {

    private String builda = "汉堡";
    private String buildb = "可乐";
    private String buildc = "薯条";
    private String buildd = "甜点";



    @Override
    public String toString () {
        return "Product{" +
                "builda='" + builda + '\'' +
                ", buildb='" + buildb + '\'' +
                ", buildc='" + buildc + '\'' +
                ", buildd='" + buildd + '\'' +
                '}';
    }

    public String getBuilda () {
        return builda;
    }

    public void setBuilda ( String builda ) {
        this.builda = builda;
    }

    public String getBuildb () {
        return buildb;
    }

    public void setBuildb ( String buildb ) {
        this.buildb = buildb;
    }

    public String getBuildc () {
        return buildc;
    }

    public void setBuildc ( String buildc ) {
        this.buildc = buildc;
    }

    public String getBuildd () {
        return buildd;
    }

    public void setBuildd ( String buildd ) {
        this.buildd = buildd;
    }
}
```

```java
//工人（服务员）
public class Worker  extends Builder{

    public Worker () {
        product = new Product ();
    }

    private Product product;
    @Override
    Builder builderA ( String msg ) {
        product.setBuilda ( msg );
        return this;
    }

    @Override
    Builder builderB ( String msg ) {
        product.setBuildb ( msg );
        return this;
    }

    @Override
    Builder builderC ( String msg ) {
        product.setBuildc ( msg );
        return this;
    }

    @Override
    Builder builderD ( String msg ) {
        product.setBuildd ( msg );
        return this;
    }

    @Override
    Product getproduct () {
        return product;
    }
}
```

```java
//模拟一个肯德基定套餐业务，默认情况下是：汉堡.可乐.薯条.甜点
public class Test {
    public static void main ( String[] args ) {
        //产品  < -  自己决定细节 < - 工人
        Product product = new Worker ( ).builderA ( "全家桶" ).builderB ( "鸡翅" ).builderC ( "雪碧" )
                .builderD ( "冰淇淋" ).getProduct ( );
        System.out.println ( product );
    }
}
```

### 建造者模式在JDK中的应用

```java
StringBuilder s = new StringBuilder ( "这是" )
        .append ( "JDK" )
        .append ( "中的" )
        .append ( "建造者模式" );
System.out.println ( s );
```

> **工厂模式注重把这个产品创造出来即可，而建造者更关心创建的细节，当创建一个对象需要使用很多步骤去完成的时候，我们可以考虑建造者模式，当创建一个对象比较简单的时候，我们就可以使用工厂模式。通俗一点来理解，建造者模式更像是专门定做一个东西，terator()作为一个工厂方法，它是可以有不同的厂家，但是呢，它完成的都是遍历的功能，而建造者更像是你买一个戒指，你不仅仅要求它能戴在手上，更加希望你的名字被刻在上面这样。就是关注到产品细节的就可以用建造者模式。**

## 原型模式

**原型模式，属于对象创建型模式中的一种。通过复制原型对象的方法来创建一个对象实例，且该对象与原对象有相同的数据结构和值。**



 **简单理解JVM内存中栈和堆**

　　**栈:**用来存放函数中定义的基本类型的变量和对象的引用变量。

　　**堆:**则是存放由new创建的对象和数组，对象内存储普通的变量和方法。对象创建后将其地址赋值给栈中的引用变量。

　　**方法区:**也是堆，这里面存放类代码、静态变量、静态方法和字符串常量等。



实现一个原型模式的基本步骤

1. 实现一个接口 Cloneable
2. 重写一个方法 clone()

```java
public class Video implements Cloneable {
    private String name;
    private Date creatTime;


    public Video ( String name, Date creatTime ) {
        this.name = name;
        this.creatTime = creatTime;
    }

    public Video () {
    }

    @Override
    public String toString () {
        return "Video{" +
                "name='" + name + '\'' +
                ", creatTime=" + creatTime +
                '}';
    }

    public String getName () {
        return name;
    }

    public void setName ( String name ) {
        this.name = name;
    }

    public Date getCreatTime () {
        return creatTime;
    }

    public void setCreatTime ( Date creatTime ) {
        this.creatTime = creatTime;
    }

    @Override
    protected Object clone () throws CloneNotSupportedException {
        return super.clone ( );
    }
}
```

```java
public class Client {
    public static void main ( String[] args ) throws CloneNotSupportedException {
        Date date = new Date ( );
        Video v1 = new Video ("海贼王", date);
        System.out.println ( "v1 => " + v1 );
        System.out.println ( "v1.hashcode => " + v1.hashCode () );


        Video v2 = (Video) v1.clone ( );
        System.out.println ( "v2 => " + v2 );
        System.out.println ( "v2.hashcode => " + v2.hashCode () );
    }
}
```

结果：

![结果](https://i.loli.net/2020/03/08/vcoxHEbGkihBzwJ.png)



我们修改一下代码:

```java
public class Client {
    public static void main ( String[] args ) throws CloneNotSupportedException {
        Date date = new Date ( );
        Video v1 = new Video ("海贼王", date);
        Video v2 = (Video) v1.clone ( );
        System.out.println ( "v1 => " + v1 );
        System.out.println ( "v2 => " + v2 );
        date.setTime ( 124123421 );
        System.out.println ( "-------------------我是分界线-----------------" );
        System.out.println ( "v1 => " + v1 );
        System.out.println ( "v2 => " + v2 );
    }
}
```

结果：

![](https://i.loli.net/2020/03/08/oqutBdbDW1nQ8CZ.png)

可以看到我们期望的情况是v1.data修改，结果v2.data也修改了。

![](https://i.loli.net/2020/03/08/gpkGxKyLHwJTfmi.png)

实现深拷贝的方法：

1.修改clone方法

2.序列化与反序列化

```java
@Override
protected Object clone () throws CloneNotSupportedException {

    Object object =  super.clone ( );
    Video v = (Video) object;
    v.creatTime = (Date)this.creatTime.clone ();
    return object;
}
```



### 原型模式在JDK中的应用

1. Spring Bean创建：1.单例模式  2.原型模式
2. Hashtable

```java
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable {}
    

public synchronized Object clone() {
    Hashtable<?,?> t = cloneHashtable();
    t.table = new Entry<?,?>[table.length];
    for (int i = table.length ; i-- > 0 ; ) {
        t.table[i] = (table[i] != null)
            ? (Entry<?,?>) table[i].clone() : null;
    }
    t.keySet = null;
    t.entrySet = null;
    t.values = null;
    t.modCount = 0;
    return t;
}

```