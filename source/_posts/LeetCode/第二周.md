---
title: LeetCode刷题：第二周
date: 2020-03-21T15:17
author: codezhw
top: false
categories: 算法
tags: 
	- Java
	- LeetCode
---







# 第二周



## 题目：[482. 密钥格式化](https://leetcode-cn.com/problems/license-key-formatting/)



给定一个密钥字符串S，只包含字母，数字以及 '-'（破折号）。N 个 '-' 将字符串分成了 N+1 组。给定一个数字 K，重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符，第一个分组至少要包含 1 个字符。两个分组之间用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。

给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

**示例 1：**

```
输入：S = "5F3Z-2e-9-w", K = 4

输出："5F3Z-2E9W"

解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
```

**示例 2：**

```
输入：S = "2-5g-3-J", K = 2

输出："2-5G-3J"

解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
```

**解题思路：**



- 将字符串转化为字符数组，并全部变为大写。

- 从后往前遍历，在头部插入元素。

- 定义一个计数器count 记录插入的元素个数，当元素个数 % K==0的时候插入一个'-'。

  



**代码**

```java
//482. 密钥格式化
    public String licenseKeyFormatting ( String S, int K ) {

        String replace = S.replace ( "-", "" ).toUpperCase ( );
        StringBuilder stringBuilder = new StringBuilder ( );
        char[] chars = replace.toCharArray ( );
        int i = chars.length - 1;
        int count = 0;
        while (i >= 0) {
            stringBuilder.insert ( 0, chars[i--] );
            count++;
            if (count % K == 0 && i >= 0) {
                stringBuilder.insert ( 0, "-" );
            }
        }
        return stringBuilder.toString ( );
    }
```



## 题目：[202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

编写一个算法来判断一个数是不是“快乐数”。

一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。

示例: 

输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1



**解题思路：**

- 根据题意可能会无线循环，所以我们优先判断为false的情况。
- 因为题目找的就是hash表的，通过观察可以发现，如果两个数的合在之前出现过那么就会陷入死循环。
- 通过判断这个结果是否在之前出现可以提前结束循环，利用HashSet去判断是否出现重复。



**代码：**

~~~java
public static boolean isHappy ( int n ) {
    HashSet <Integer> set = new HashSet <> ( );
    set.add ( n );
    while (n != 1) {
        n = change ( n );
        if (set.contains ( n )) {
            return false;
        }
        set.add ( n );
    }
    return true;
}

public static int change ( int n ) {

    int num = 0;
    while (n != 0) {
        num += Math.pow ( n % 10, 2 );
        n /= 10;
    }
    return num;
}
~~~





## 题目：[9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。



**解题思路：**

- 首先负数的回文一定不想当，所以直接false。
- 然后正常操作

**代码：**



```java
public static boolean isPalindrome ( int x ) {
    if (x < 0) {
        return false;
    }
    int num = 0;
    int tmp = x;
    int len = String.valueOf ( x ).length ( );
    while (len > 0) {
        num += x % 10 * (int) Math.pow ( 10, len - 1 );
        x /= 10;
        len--;
    }
    return num == tmp;
}
```