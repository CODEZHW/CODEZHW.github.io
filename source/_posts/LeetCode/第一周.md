---
title: LeetCode刷题:第一周
date: 2020-03-13T13:23
author: codezhw
top: false
categories: 算法
tags: 
	- Java
	- LeetCode

---





# 第一周





## 题目：[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。**

**如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。**

**注意你不能在买入股票前卖出股票。**

示例 1:

~~~bash
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
~~~

示例 2:

~~~bash
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
~~~

**解题思路：**

- 第一种：暴力
  - 直接双重循环遍历数组，找出在j>i情况下 price[j]-price[i]的最大值。
  - 效率很低 O(n^2)
- 第二种：一次遍历
  - 维护两个值，一个是当前股票的价格  `currpri = prices[0]`，当前最大利润 `pro = 0`;
  - 遍历数组中的每支股票，判断它是否小于当前股票，如果是买入；不是，则计算卖出当前股票得到的利润
  - 然后与当前利润进行比较

**代码：**

```java
public static int maxProfit ( int[] prices ) {

	//方法一
    int max = 0;
    for (int i = 0; i < prices.length; i++) {
        for (int j = i + 1; j < prices.length; j++) {
        max = max <  prices[j] - prices[i] ? prices[j] - prices[i] : max;
        }
    }
    return max;
    
    //方法二
    if (prices.length == 0 || prices == null) {
        return 0;
    }
    int pro = 0;
    int currPri = prices[0];
    for (int i = 1; i < prices.length; i++) {
        if (currPri > prices[i]) {
            currPri = prices[i];
        } else {
            int tempPro = prices[i] - currPri;
            pro = Math.max ( tempPro, pro );
        }
    }
    return pro;
}
```





## 题目： [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)



**反转一个单链表。**

**示例:**

```bash
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```



**解题思路：**

- 双指针的方法，因为要进行节点切换，所以要定义三个变量
- pre = tmp  指向null ，cur = head;cur和pre同时移动，移动到最后pre就是头节点。
- 循环条件 cur !=null; 双指针后移，tmp记录cur的下一个节点tmp = cur.next;
- 断开cur->next,将cur指向pre
- 将pre->cur，将pre指向cur
- cur->tmp,将cur指向tmp

**代码：**

```java
public ListNode reverseList ( ListNode head ) {

    ListNode pre = null;
    ListNode cur = head;
    ListNode tmp = null;
    while (cur!=null){
        tmp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
```





## 题目：[面试题 01.06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)



**字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。**



**示例1:**

~~~bash
 输入："aabcccccaaa"
 输出："a2b1c5a3"
~~~

**示例2:**

~~~bash
 输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
~~~

**解题思路：**

- 双指针 维护两个变量i,j 初始:i=j; 并将字符串S转化为字符数组chars去遍历 。
- 如果chars[i] == [j]; j++; 如果不相等；字符串添加 chars[i]和j-i;然后赋值i=j。



**代码：**

```java
public static String compressString ( String S ) {
    
    StringBuffer stringBuffer = new StringBuffer ( );
    char[] chars = S.toCharArray ( );
    int count = 0;
    int i = 0;
    while (i < S.length ( )) {
        int j = i;
        while (j < S.length ( ) && (chars[j] ^ chars[i]) == 0) {
            j++;
        }
        stringBuffer.append ( chars[i] );
        stringBuffer.append ( j-i );
        i = j;
    }
    return stringBuffer.length ( ) >= S.length ( ) ? S : stringBuffer.toString ();
}
```





## 题目：[169. 多数元素](https://leetcode-cn.com/problems/majority-element/)



**给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。**

**你可以假设数组是非空的，并且给定的数组总是存在多数元素。**



示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2

**解题思路：**

- 解法一：
  - 维护两个值一个记录当前最大元素res,一个记录当前元素的最大值。
  - 利用HashMap的特点，将数组的每个元素作为key, 元素出现次数作为value
  - 因为给定的数组总是存在多数元素，所以如果当前元素出现次数大于nums.length/2 返回当前元素



**代码:**

```java
//169. 多数元素
public static int majorityElement ( int[] nums ) {
    HashMap <Integer, Integer> map = new HashMap <> ( );
    int max = 0;
    int res = 0;
    for (int num : nums) {
        if (!map.containsKey ( num )) {
            map.put ( num, 1 );
        } else {
            map.put ( num, map.get ( num ) + 1 );
        }
        if (map.get ( num ) > nums.length / 2) {
            return num;
        }

    }
    return -1;
}
```





## 题目：[面试题40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

**输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。**

**示例 1：**

输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
**示例 2：**

输入：arr = [0,1,2,1], k = 1
输出：[0]



**解题思路：**

- 快速排序，然后输出前K个数
- Arrays.sort()方法就是快速排序
- 时间效率：O(nlogn)
- 可以对快速排序进行改进，在找到K个最小的数时停止之后其他数的排序。



**代码：**

```java
public static int[] getLeastNumbers ( int[] arr, int k ) {
    //调库
    Arrays.sort ( arr );
    return Arrays.copyOf ( arr, k );
    
    //手写快排 这和上面那种一样
    quicksort(arr, 0, arr.length-1);
    return Arrays.copyOf ( arr, k );
  	
}

	
   public static void quicksort ( int arr[], int low, int high ) {
        if (low > high) {
            return;
        }
        int i = low;
        int j = high;
        //基准
        int tmp = arr[low];

        while (i < j) {
            while (tmp <= arr[j] && i < j) {
                j--;
            }
            while (tmp >= arr[i] && i < j) {
                i++;
            }
            if (i < j) {
                int t = arr[i];
                arr[i] = arr[j];
                arr[j] = t;
            }
        }
        arr[low] = arr[i];
        arr[i] = tmp;

        quicksort ( arr, low, j - 1 );
        quicksort ( arr, j + 1, high );
    }

```



## 题目：[1160. 拼写单词](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/)



**给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。**

**假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。**

**注意：每次拼写时，chars 中的每个字母都只能用一次。**

**返回词汇表 words 中你掌握的所有单词的 长度之和。**

 

**示例 1：**

输入：words = ["cat","bt","hat","tree"], chars = "atach"
输出：6

解释： 
可以形成字符串 "cat" 和 "hat"，所以答案是 3 + 3 = 6。

**示例 2：**

输入：words = ["hello","world","leetcode"], chars = "welldonehoneyr"
输出：10

解释：
可以形成字符串 "hello" 和 "world"，所以答案是 5 + 5 = 10。



**解题思路：**

- 26个字母，我们可以用一个长度为26的数组存储。通过c[cc-'a']将这个字符串存入到数组中。
- 根据这个原理定义两个数组int [] c, int[] w;c存储判断的字符串，w存储每个单词。
- 通过比较w[i]是否大于c[i]，如果是，则继续循环；如果不是，则表示这个单词可以拼写，记录。



**代码：**

```java
public static int countCharacters ( String[] words, String chars ) {
    int[] c = new int[26];
    for (char cc : chars.toCharArray ( )) {
        c[(int) (cc - 'a')] += 1;
    }
    int res = 0;
  a: for (String word : words) {
        int[] w = new int[26];
        for (char ww : word.toCharArray ( )) {
            w[(int) (ww - 'a')] += 1;
        }
        for (int i = 0; i < 26; i++) {
            if (w[i] > c[i]) {
                continue a;
            }
        }
        res += word.length ( );
    }
    return res;
}
```





## 题目：[面试题 01.01. 判定字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)



**实现一个算法，确定一个字符串 s 的所有字符是否全都不同。**

**示例 1：**

输入: s = "leetcode"
输出: false 

**示例 2：**

输入: s = "abc"
输出: true
限制：

**0 <= len(s) <= 100**
**如果你不使用额外的数据结构，会很加分。**

**解题思路：**

- 用String.replace()方法去替换字符串中的每个字符，然后判断他与原来的字符长度-1是否相等
- 在循环中建立一个astr复本，保证每次判断的字符都是传入的字符。



**代码：**

```java
//面试题 01.01. 判定字符是否唯一
public static boolean isUnique ( String astr ) {
    for (int i = 0; i < astr.length ( ); i++) {
        String s = astr;
        s = s.replace ( String.valueOf ( s.charAt ( i ) ), "" );
        if (s.length ( ) != astr.length ( ) - 1) {
            return false;
        }
    }
    return true;
}
```





## 题目：[836. 矩形重叠](https://leetcode-cn.com/problems/rectangle-overlap/)





矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标，`(x2, y2)` 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。

 

**示例 1：**

```
输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
```

**示例 2：**

```
输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
```





**解题思路：**

首先如果两个矩阵重叠，那么它们在x&y轴上的投影也一定重叠，从这个角度出发将二维的问题转化为两个一维的问题去解决。

假设两个矩阵rec1 = [Xs1, Xe1, Ys1, Ye1], rec2 = [Xs2, Xe2, Ys2, Ye2]

对X轴来说，去判断投影重叠的情况比较多，我们可以从投影不重叠去判断然后把结果取反也是一样的。



X不重叠： Xe1 <= Xs2 || Xe2 <= Xs1 

Y不重叠： Ye1 <= Ys2 || Ye2 <= Ys1 



**代码：**

```java
public static boolean isRectangleOverlap ( int[] rec1, int[] rec2 ) {

    boolean x = !(rec1[2] <= rec2[0] || rec2[2] <= rec1[0]);
    boolean y = !(rec1[3] <= rec2[1] || rec2[3] <= rec1[1]);

    return x & y;
}
```



## 题目：[409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 `"Aa"` 不能当做一个回文字符串。

**注意:**
假设字符串的长度不会超过 1010。

**示例 1:**

```
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```



**解题思路：**



做过拼写单词的题目这道题也很容易能想到，用一个长度为42（大小写）的字符数组来保存。

然后遍历数组，因为偶数是中心对称的，所以所有的偶数字符都可以组成回文串。

有几种特殊情况：

- 没有奇数直接返回整个数组个数
- 只有一个奇数，返回整个数组 + 1
- 有多个奇数，就把每个奇数-1变成偶数，用总的 - 去掉的奇数个数再+1



**代码：**

```java
public static int longestPalindrome ( String s ) {

    int[] c = new int[26 + 26];
    for (char ss : s.toCharArray ( )) {
        if (ss >= 'a') {
            c[ss - 'a'] += 1;
        } else {
            c[ss - 'A' + 26] += 1;
        }
    }
    int res = 0;
    int odd = 0;
    for (int cc : c) {
        res += cc;
        if (cc % 2 == 1) {
            odd += 1;
        }
    }
    return odd == 0 ? res : res - odd + 1;
}
```

